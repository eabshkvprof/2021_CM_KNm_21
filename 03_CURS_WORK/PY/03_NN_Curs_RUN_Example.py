"""
ПРИМЕРЫ ДЛЯ КУРСОВОГО
ПРИМЕР ОРГАНИЗАЦИИ ВЕКТОРОВ - МАТРИЦ
ШАБЛОН RUN ПРОГОН СЕТИ ПО ВСЕМ ВХОДНЫМ ВЕКТОРАМ
ПРОСТЕЙШИЙ ПРИМЕР 14 тестовых веторов по 4 признака каждый
"""

import numpy as np
import matplotlib.pyplot as plt
import skimage.io as io


def activation_function(s):
    # функция активации sigmoid:: f(x) = 1 / (1 + e^(-x))
    activ_out = 1 / (1 + np.exp(-s))
    # избегаем точных значений 0 и 1
    if activ_out == 1: activ_out = 0.999999
    if activ_out == 0: activ_out = 0.000001
    return activ_out

# векторизация функции активации
def vector_activation_function():
    return np.vectorize(activation_function)


# Создание СПИСКА МАТРИЦ весов входов нейронов + вес смещения
# Каждый элемент списка есть МАТРИЦА весов для одного слоя
# МАТРИЦА весов l-го слоя для КАЖДОГО нейрона слоя содержит вектор весов,
# ПРИЧЕМ этот вектор имеет размерость = количество нейронов L-1 слоя + 1 для смещения
# весы случайные числа в диапазоне -1 <--> 1
#
def create_weights (layers):
    weights_list = [0]
    # нулевой слой ПРОПУСКАЕМ
    for l in range (1, len(layers)): # перебираем слои
        weights_list.append(np.mat(np.random.uniform(-1,1, (layers[l],layers[l-1]+1))))  # числа с плавающей
    return weights_list


# Описание сети СПИСОК количества нейронов в каждом  слое
Net_Layers = [4, 5, 3, 1]
print ('Слои :', Net_Layers)

# Генерация СПИСКА начальных весов (выполнять только один раз)
# Для каждого слоя для каждого нейрона форимруется вектор весов
# О-й слой (входной) веса не формируются.

nn_weights = create_weights (Net_Layers)
print ('Слой номер ', 0, 'Нейронов в ',0,'-м слое ', Net_Layers[0])
for l in range (1, len(Net_Layers)): # перебираем слои
    print ('Слой номер ', l, 'Нейронов в',l,'-м слое ', Net_Layers[l])
    print ('Веса слоя',  nn_weights[l])


# Тренировочные наборы
N_Train = 14 # Количество тренировчных наборов
# Входные тренировочные вектора - признаки 
xTrain = [[1, 2.3, 4.5, 5.3],
          [1.1, 1.3, 2.4, 2.4],
          [1.9, 1.7, 1.5, 1.3],
          [2.3, 2.9, 3.3, 4.9],
          [3, 5.2, 6.1, 8.2],
          [3.31, 2.9, 2.4, 1.5],
          [4.9, 5.7, 6.1, 6.3],
          [4.85, 5.0, 7.2, 8.1],
          [5.9, 5.3, 4.2, 3.3],
          [7.7, 5.4, 4.3, 3.9],
          [6.7, 5.3, 3.2, 1.4],
          [7.1, 8.6, 9.1, 9.9],
          [8.5, 7.4, 6.3, 4.1],
          [9.8, 5.3, 3.1, 2.9]]

# Выходные тренировочные вектора (Labels, Метки)
yTrain = [[1], [1], [0], [1], [1],
          [0], [1], [1], [0], [0],
          [0], [1], [0], [0]]

print('------ТРЕНИРОВОЧНЫЕ НАБОРЫ------------------')
for i in range (0, N_Train):
    answer = "Восходящая"
    if yTrain[i][0] == 0: answer = "Нисходящая"
    print ('Входной вектор ', xTrain[i], 'Выход', yTrain[i], answer)

# ПРОТОТИП ФУНКЦИИ RUN
def main():

    # m     Количество входных векторв для тренировки
    # s     взвешенное произведение входов на веса для текущего слоя
    # S     ПОСЛОЙНЫЙ СИСОК s
    # y     выходы функции активации нейронов в текущем слое
    # Y     ПОСЛОЙНЫЙ СИСОК y

    m = len(xTrain)
    print ('Количество входных векторов = ', m)

    # СЛОЙ НОЛЬ
    # Матрица СУММ ПРОИЗВЕДЕНИЙ
    S =  [0]  # Никаих взвешенных сумм нет
    Y = [np.copy(xTrain)] # Выход слоя 0 просто массив тренировочных веторов

    print('Начальные значения векторв')
    print(Y)

    # Делаем векторную функцию активации (векторизация функции)
    Log_Func = vector_activation_function( )

    for l in range(1, len(Net_Layers)): # перебираем слои исключая входной (0-й)
        Y[l-1] = np.c_[np.ones(m), Y[l-1]] # добавляем псевдовход -> смещение b = 1
        print ('----------------------------------------------------')
        print ('--СЛОЙ ',l,' НЕЙРОНОВ в СЛОЕ ',Net_Layers[l],' ВХОДНЫХ НЕЙРОНОВ', Net_Layers[l-1])
        print ('Вход слоя ', Y[l-1])
        s = nn_weights[l] * Y[l-1].T # вычисляем сумму взвешенных входных сигналов слоя
        print ('Входы функции активации = ', s)
        y = (Log_Func(s)).T  # вычисляем выходы нейронов слоя
        print ('Выходы нейронов h = ', y)

        S.append(s) # Добавляем в послойный список взвешенных сумм
    #    print ('Входы функции активации appended в список ', S)
        Y.append(y) # Добавляем в список выходв
    #    print ('Выходы нейронов appended в список ', Y)


if __name__ == '__main__':
    main()

